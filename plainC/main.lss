
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  0000042c  000004c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000042c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  0080010a  0080010a  000004ca  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  000004ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000004dc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  0000051c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000f89  00000000  00000000  00000564  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ba1  00000000  00000000  000014ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000003de  00000000  00000000  0000208e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000108  00000000  00000000  0000246c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000658  00000000  00000000  00002574  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000002a7  00000000  00000000  00002bcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  00002e73  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 cc 00 	jmp	0x198	; 0x198 <__ctors_end>
   4:	0c 94 fc 00 	jmp	0x1f8	; 0x1f8 <__vector_1>
   8:	0c 94 0b 01 	jmp	0x216	; 0x216 <__vector_2>
   c:	0c 94 1a 01 	jmp	0x234	; 0x234 <__vector_3>
  10:	0c 94 29 01 	jmp	0x252	; 0x252 <__vector_4>
  14:	0c 94 38 01 	jmp	0x270	; 0x270 <__vector_5>
  18:	0c 94 47 01 	jmp	0x28e	; 0x28e <__vector_6>
  1c:	0c 94 56 01 	jmp	0x2ac	; 0x2ac <__vector_7>
  20:	0c 94 65 01 	jmp	0x2ca	; 0x2ca <__vector_8>
  24:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__vector_9>
  28:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  2c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  30:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  34:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  38:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  3c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  40:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  44:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  48:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  4c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  50:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  54:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  58:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  5c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  60:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  64:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  68:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  6c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  70:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  74:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  78:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  7c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  80:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  84:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  88:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  8c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  90:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
  94:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>

00000098 <PS2Keymap_Shifted>:
  98:	7f bd 7f 38 33 34 31 39 7f b8 b3 b4 3d 3a 86 7f     ...83419....=:..
  a8:	7f 36 35 7f 30 21 80 7f 7f 7f 2b 2d 11 2f 95 7f     .65.0!....+-./..
  b8:	7f 1d 2c 18 1e 87 82 7f 7f 45 2a 1a 28 23 84 7f     ..,......E*.(#..
  c8:	7f 22 13 1c 1f 29 7f 7f 7f 7f 26 1b 2e 83 15 7f     ."...)....&.....
  d8:	7f 96 25 19 27 85 88 7f 7f 92 97 20 10 24 8e 7f     ..%.'...... .$..
  e8:	7f 94 8b 7f 8c 8a 7f 7f 32 35 3b 09 7f 89 7f 7f     ........25;.....
  f8:	7f 7f 7f b1 7f 7f 3c 7f 7f 00 7f 07 03 12 7f 7f     ......<.........
 108:	05 16 06 04 01 0d 3e 7f 39 8a 02 0e 15 08 7f 7f     ......>.9.......

00000118 <PS2Keymap_Normal>:
 118:	7f bd 7f 38 33 34 31 3f 7f b8 b3 b4 3d 3a 8d 7f     ...8341?....=:..
 128:	7f 36 35 7f 30 21 00 7f 7f 7f 2b 2d 11 2f 06 7f     .65.0!....+-./..
 138:	7f 1d 2c 18 1e 07 02 7f 7f 45 2a 1a 28 23 04 7f     ..,......E*.(#..
 148:	7f 22 13 1c 1f 29 01 7f 7f 7f 26 1b 2e 03 0d 7f     ."...)....&.....
 158:	7f 16 25 19 27 05 08 7f 7f 12 17 20 10 24 0e 7f     ..%.'...... .$..
 168:	7f 14 0b 7f 0c 0a 7f 7f 32 35 3b 0f 7f 8f 7f 7f     ........25;.....
 178:	7f 7f 7f b1 7f 7f 3c 7f 7f 00 7f 07 03 12 7f 7f     ......<.........
 188:	05 16 06 04 01 0d 3e 7f 39 8a 02 0e 15 08 7f 7f     ......>.9.......

00000198 <__ctors_end>:
 198:	11 24       	eor	r1, r1
 19a:	1f be       	out	0x3f, r1	; 63
 19c:	cf ef       	ldi	r28, 0xFF	; 255
 19e:	d0 e2       	ldi	r29, 0x20	; 32
 1a0:	de bf       	out	0x3e, r29	; 62
 1a2:	cd bf       	out	0x3d, r28	; 61

000001a4 <__do_copy_data>:
 1a4:	11 e0       	ldi	r17, 0x01	; 1
 1a6:	a0 e0       	ldi	r26, 0x00	; 0
 1a8:	b1 e0       	ldi	r27, 0x01	; 1
 1aa:	ec e2       	ldi	r30, 0x2C	; 44
 1ac:	f4 e0       	ldi	r31, 0x04	; 4
 1ae:	00 e0       	ldi	r16, 0x00	; 0
 1b0:	0b bf       	out	0x3b, r16	; 59
 1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <__do_copy_data+0x14>
 1b4:	07 90       	elpm	r0, Z+
 1b6:	0d 92       	st	X+, r0
 1b8:	aa 30       	cpi	r26, 0x0A	; 10
 1ba:	b1 07       	cpc	r27, r17
 1bc:	d9 f7       	brne	.-10     	; 0x1b4 <__do_copy_data+0x10>

000001be <__do_clear_bss>:
 1be:	21 e0       	ldi	r18, 0x01	; 1
 1c0:	aa e0       	ldi	r26, 0x0A	; 10
 1c2:	b1 e0       	ldi	r27, 0x01	; 1
 1c4:	01 c0       	rjmp	.+2      	; 0x1c8 <.do_clear_bss_start>

000001c6 <.do_clear_bss_loop>:
 1c6:	1d 92       	st	X+, r1

000001c8 <.do_clear_bss_start>:
 1c8:	af 30       	cpi	r26, 0x0F	; 15
 1ca:	b2 07       	cpc	r27, r18
 1cc:	e1 f7       	brne	.-8      	; 0x1c6 <.do_clear_bss_loop>
 1ce:	0e 94 10 02 	call	0x420	; 0x420 <main>
 1d2:	0c 94 14 02 	jmp	0x428	; 0x428 <_exit>

000001d6 <__bad_interrupt>:
 1d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001da <__vector_9>:
  DDRC = COLUMN_status [8];
  }
*/
volatile uint8_t zero = 0;
ISR (PCINT0_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 1da:	1f b6       	in	r1, 0x3f	; 63
 1dc:	aa bd       	out	0x2a, r26	; 42
 1de:	bb bd       	out	0x2b, r27	; 43
 1e0:	b1 e0       	ldi	r27, 0x01	; 1
 1e2:	a8 b1       	in	r26, 0x08	; 8
 1e4:	a0 50       	subi	r26, 0x00	; 0
 1e6:	ac 91       	ld	r26, X
 1e8:	a7 b9       	out	0x07, r26	; 7
 1ea:	aa b5       	in	r26, 0x2a	; 42
 1ec:	bb b5       	in	r27, 0x2b	; 43
 1ee:	d9 9a       	sbi	0x1b, 1	; 27
 1f0:	1f be       	out	0x3f, r1	; 63
 1f2:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 1f6:	18 95       	reti

000001f8 <__vector_1>:

};

// COLUMN_STATUS[0]
ISR (INT0_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 1f8:	1f b6       	in	r1, 0x3f	; 63
 1fa:	aa bd       	out	0x2a, r26	; 42
 1fc:	bb bd       	out	0x2b, r27	; 43
 1fe:	b1 e0       	ldi	r27, 0x01	; 1
 200:	a0 b1       	in	r26, 0x00	; 0
 202:	a0 50       	subi	r26, 0x00	; 0
 204:	ac 91       	ld	r26, X
 206:	a7 b9       	out	0x07, r26	; 7
 208:	aa b5       	in	r26, 0x2a	; 42
 20a:	bb b5       	in	r27, 0x2b	; 43
 20c:	e1 9a       	sbi	0x1c, 1	; 28
 20e:	1f be       	out	0x3f, r1	; 63
 210:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 214:	18 95       	reti

00000216 <__vector_2>:

};

// COLUMN_STATUS[1]
ISR (INT1_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 216:	1f b6       	in	r1, 0x3f	; 63
 218:	aa bd       	out	0x2a, r26	; 42
 21a:	bb bd       	out	0x2b, r27	; 43
 21c:	b1 e0       	ldi	r27, 0x01	; 1
 21e:	a1 b1       	in	r26, 0x01	; 1
 220:	a0 50       	subi	r26, 0x00	; 0
 222:	ac 91       	ld	r26, X
 224:	a7 b9       	out	0x07, r26	; 7
 226:	aa b5       	in	r26, 0x2a	; 42
 228:	bb b5       	in	r27, 0x2b	; 43
 22a:	e1 9a       	sbi	0x1c, 1	; 28
 22c:	1f be       	out	0x3f, r1	; 63
 22e:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 232:	18 95       	reti

00000234 <__vector_3>:
    );

};
// COLUMN_STATUS[2]
ISR (INT2_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 234:	1f b6       	in	r1, 0x3f	; 63
 236:	aa bd       	out	0x2a, r26	; 42
 238:	bb bd       	out	0x2b, r27	; 43
 23a:	b1 e0       	ldi	r27, 0x01	; 1
 23c:	a2 b1       	in	r26, 0x02	; 2
 23e:	a0 50       	subi	r26, 0x00	; 0
 240:	ac 91       	ld	r26, X
 242:	a7 b9       	out	0x07, r26	; 7
 244:	aa b5       	in	r26, 0x2a	; 42
 246:	bb b5       	in	r27, 0x2b	; 43
 248:	e1 9a       	sbi	0x1c, 1	; 28
 24a:	1f be       	out	0x3f, r1	; 63
 24c:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 250:	18 95       	reti

00000252 <__vector_4>:

};

// COLUMN_STATUS[3]
ISR (INT3_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 252:	1f b6       	in	r1, 0x3f	; 63
 254:	aa bd       	out	0x2a, r26	; 42
 256:	bb bd       	out	0x2b, r27	; 43
 258:	b1 e0       	ldi	r27, 0x01	; 1
 25a:	a3 b1       	in	r26, 0x03	; 3
 25c:	a0 50       	subi	r26, 0x00	; 0
 25e:	ac 91       	ld	r26, X
 260:	a7 b9       	out	0x07, r26	; 7
 262:	aa b5       	in	r26, 0x2a	; 42
 264:	bb b5       	in	r27, 0x2b	; 43
 266:	e1 9a       	sbi	0x1c, 1	; 28
 268:	1f be       	out	0x3f, r1	; 63
 26a:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 26e:	18 95       	reti

00000270 <__vector_5>:

};

// COLUMN_STATUS[4]
ISR (INT4_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 270:	1f b6       	in	r1, 0x3f	; 63
 272:	aa bd       	out	0x2a, r26	; 42
 274:	bb bd       	out	0x2b, r27	; 43
 276:	b1 e0       	ldi	r27, 0x01	; 1
 278:	a4 b1       	in	r26, 0x04	; 4
 27a:	a0 50       	subi	r26, 0x00	; 0
 27c:	ac 91       	ld	r26, X
 27e:	a7 b9       	out	0x07, r26	; 7
 280:	aa b5       	in	r26, 0x2a	; 42
 282:	bb b5       	in	r27, 0x2b	; 43
 284:	e1 9a       	sbi	0x1c, 1	; 28
 286:	1f be       	out	0x3f, r1	; 63
 288:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 28c:	18 95       	reti

0000028e <__vector_6>:

};

// COLUMN_STATUS[5]
ISR (INT5_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 28e:	1f b6       	in	r1, 0x3f	; 63
 290:	aa bd       	out	0x2a, r26	; 42
 292:	bb bd       	out	0x2b, r27	; 43
 294:	b1 e0       	ldi	r27, 0x01	; 1
 296:	a5 b1       	in	r26, 0x05	; 5
 298:	a0 50       	subi	r26, 0x00	; 0
 29a:	ac 91       	ld	r26, X
 29c:	a7 b9       	out	0x07, r26	; 7
 29e:	aa b5       	in	r26, 0x2a	; 42
 2a0:	bb b5       	in	r27, 0x2b	; 43
 2a2:	e1 9a       	sbi	0x1c, 1	; 28
 2a4:	1f be       	out	0x3f, r1	; 63
 2a6:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 2aa:	18 95       	reti

000002ac <__vector_7>:

};

// COLUMN_STATUS[6]
ISR (INT6_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 2ac:	1f b6       	in	r1, 0x3f	; 63
 2ae:	aa bd       	out	0x2a, r26	; 42
 2b0:	bb bd       	out	0x2b, r27	; 43
 2b2:	b1 e0       	ldi	r27, 0x01	; 1
 2b4:	a6 b1       	in	r26, 0x06	; 6
 2b6:	a0 50       	subi	r26, 0x00	; 0
 2b8:	ac 91       	ld	r26, X
 2ba:	a7 b9       	out	0x07, r26	; 7
 2bc:	aa b5       	in	r26, 0x2a	; 42
 2be:	bb b5       	in	r27, 0x2b	; 43
 2c0:	e1 9a       	sbi	0x1c, 1	; 28
 2c2:	1f be       	out	0x3f, r1	; 63
 2c4:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 2c8:	18 95       	reti

000002ca <__vector_8>:

};

// COLUMN_STATUS[7]
ISR (INT7_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
 2ca:	1f b6       	in	r1, 0x3f	; 63
 2cc:	aa bd       	out	0x2a, r26	; 42
 2ce:	bb bd       	out	0x2b, r27	; 43
 2d0:	b1 e0       	ldi	r27, 0x01	; 1
 2d2:	a7 b1       	in	r26, 0x07	; 7
 2d4:	a0 50       	subi	r26, 0x00	; 0
 2d6:	ac 91       	ld	r26, X
 2d8:	a8 b9       	out	0x08, r26	; 8
 2da:	aa b5       	in	r26, 0x2a	; 42
 2dc:	bb b5       	in	r27, 0x2b	; 43
 2de:	e1 9a       	sbi	0x1c, 1	; 28
 2e0:	1f be       	out	0x3f, r1	; 63
 2e2:	10 90 0a 01 	lds	r1, 0x010A	; 0x80010a <__data_end>
 2e6:	18 95       	reti

000002e8 <setup>:
//                     |_|


void setup(void) {
    //Teensy++ 2.0 CPU initialization
    cli();
 2e8:	f8 94       	cli
    CLKPR = 0x80;
 2ea:	e1 e6       	ldi	r30, 0x61	; 97
 2ec:	f0 e0       	ldi	r31, 0x00	; 0
 2ee:	80 e8       	ldi	r24, 0x80	; 128
 2f0:	80 83       	st	Z, r24
    CLKPR = CPU_PRESCALER;
 2f2:	10 82       	st	Z, r1
    // End of CPU initialization
    // Enable digital input on ADC ports
    DIDR0 = 0;
 2f4:	10 92 7e 00 	sts	0x007E, r1	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
    DDRD =  0x00; // all matrix columns pins pins as inputs
    PORTD = 0x00; // all matrix columns pins open (unactive for MSX)
    */
    
    //Make sure internal pull up funcionality is enabled:
    MCUCR &= ~(_BV(PUD));
 2f8:	85 b7       	in	r24, 0x35	; 53
 2fa:	8f 7e       	andi	r24, 0xEF	; 239
 2fc:	85 bf       	out	0x35, r24	; 53

    // Interrupt pins (INT0..7)
    DDRD =  0x0F; // D0..D3 input, the rest output
 2fe:	8f e0       	ldi	r24, 0x0F	; 15
 300:	8a b9       	out	0x0a, r24	; 10
    PORTD = 0x0F; // D0..D3 pullup
 302:	8b b9       	out	0x0b, r24	; 11
    DDRE =  0xF0; // E4..E7 input
 304:	80 ef       	ldi	r24, 0xF0	; 240
 306:	8d b9       	out	0x0d, r24	; 13
    PORTE = 0xF0; // E4..E7 pullup
 308:	8e b9       	out	0x0e, r24	; 14
    
    //This one is Y8, but using a pin change interrupt.
    DDRB = 0xFE; // PB0 input. other input
 30a:	8e ef       	ldi	r24, 0xFE	; 254
 30c:	84 b9       	out	0x04, r24	; 4
    PORTB = _BV(PD0); // PB0 pullup
 30e:	81 e0       	ldi	r24, 0x01	; 1
 310:	85 b9       	out	0x05, r24	; 5
    

    DDRD |= _BV(PD6); //Port 6 OUTPUT
 312:	56 9a       	sbi	0x0a, 6	; 10
    PORTD |= _BV(PD6); //Port 6 HIGH
 314:	5e 9a       	sbi	0x0b, 6	; 11

    // Output pins (simulates matrix)
    DDRC = 0xFF; // PORTC (10 to 18 in teensy++ 2.0) is the column output
 316:	8f ef       	ldi	r24, 0xFF	; 255
 318:	87 b9       	out	0x07, r24	; 7
    PORTC = 0xFF; // write high on all ports
 31a:	88 b9       	out	0x08, r24	; 8
    
    UCSR1B = 0; // disable USART
 31c:	10 92 c9 00 	sts	0x00C9, r1	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
 320:	08 95       	ret

00000322 <loop>:


void loop(void) {
  for (;;) {
      _delay_ms(1000);
      PORTD ^= _BV(PD6); //Port D6 (led) toggle
 322:	90 e4       	ldi	r25, 0x40	; 64
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 324:	2f ef       	ldi	r18, 0xFF	; 255
 326:	33 ed       	ldi	r19, 0xD3	; 211
 328:	80 e3       	ldi	r24, 0x30	; 48
 32a:	21 50       	subi	r18, 0x01	; 1
 32c:	30 40       	sbci	r19, 0x00	; 0
 32e:	80 40       	sbci	r24, 0x00	; 0
 330:	e1 f7       	brne	.-8      	; 0x32a <loop+0x8>
 332:	00 c0       	rjmp	.+0      	; 0x334 <loop+0x12>
 334:	00 00       	nop
 336:	8b b1       	in	r24, 0x0b	; 11
 338:	89 27       	eor	r24, r25
 33a:	8b b9       	out	0x0b, r24	; 11
 33c:	f3 cf       	rjmp	.-26     	; 0x324 <loop+0x2>

0000033e <writePS2>:
void writePS2(uint8_t data) {
  uint8_t i;
  uint8_t parity = 1;

  // prepare for transmit
  releaseCLK();
 33e:	20 98       	cbi	0x04, 0	; 4
 340:	28 9a       	sbi	0x05, 0	; 5
  releaseDAT();
 342:	21 98       	cbi	0x04, 1	; 4
 344:	29 9a       	sbi	0x05, 1	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 346:	ef e1       	ldi	r30, 0x1F	; 31
 348:	f3 e0       	ldi	r31, 0x03	; 3
 34a:	31 97       	sbiw	r30, 0x01	; 1
 34c:	f1 f7       	brne	.-4      	; 0x34a <writePS2+0xc>
 34e:	00 c0       	rjmp	.+0      	; 0x350 <writePS2+0x12>
 350:	00 00       	nop
  _delay_us(200);

  // http://www.burtonsys.com/ps2_chapweske.htm
  // 1)   Bring the Clock line low for at least 100 microseconds.
  dropCLK();
 352:	20 9a       	sbi	0x04, 0	; 4
 354:	28 98       	cbi	0x05, 0	; 5
 356:	e7 e5       	ldi	r30, 0x57	; 87
 358:	f2 e0       	ldi	r31, 0x02	; 2
 35a:	31 97       	sbiw	r30, 0x01	; 1
 35c:	f1 f7       	brne	.-4      	; 0x35a <writePS2+0x1c>
 35e:	00 c0       	rjmp	.+0      	; 0x360 <writePS2+0x22>
 360:	00 00       	nop
  _delay_us(150);

  // 2)   Bring the Data line low.
  dropDAT();
 362:	21 9a       	sbi	0x04, 1	; 4
 364:	29 98       	cbi	0x05, 1	; 5
 366:	f5 e3       	ldi	r31, 0x35	; 53
 368:	fa 95       	dec	r31
 36a:	f1 f7       	brne	.-4      	; 0x368 <writePS2+0x2a>
 36c:	00 00       	nop
  _delay_us(10);

  // 3)   Release the Clock line.
  releaseCLK();
 36e:	20 98       	cbi	0x04, 0	; 4
 370:	28 9a       	sbi	0x05, 0	; 5
 372:	9a e1       	ldi	r25, 0x1A	; 26
 374:	9a 95       	dec	r25
 376:	f1 f7       	brne	.-4      	; 0x374 <writePS2+0x36>
 378:	00 c0       	rjmp	.+0      	; 0x37a <writePS2+0x3c>

  _delay_us(5); // give some time for the line to raise

  // 4)   Wait for the device to bring the Clock line low.
  waitCLKfall();
 37a:	18 99       	sbic	0x03, 0	; 3
 37c:	fe cf       	rjmp	.-4      	; 0x37a <writePS2+0x3c>
 37e:	28 e0       	ldi	r18, 0x08	; 8
 380:	91 e0       	ldi	r25, 0x01	; 1


  for (i = 0; i < 8; i++)
  {
    // 5)   Set/reset the Data line to send the first data bit
    if (data & 0x01)
 382:	80 ff       	sbrs	r24, 0
 384:	04 c0       	rjmp	.+8      	; 0x38e <writePS2+0x50>
    {
      releaseDAT();
 386:	21 98       	cbi	0x04, 1	; 4
 388:	29 9a       	sbi	0x05, 1	; 5
      parity++;
 38a:	9f 5f       	subi	r25, 0xFF	; 255
 38c:	02 c0       	rjmp	.+4      	; 0x392 <writePS2+0x54>
    } else {
      dropDAT();
 38e:	21 9a       	sbi	0x04, 1	; 4
 390:	29 98       	cbi	0x05, 1	; 5
    }
    // 6)   Wait for the device to bring Clock high.
    waitCLKrise();
 392:	18 9b       	sbis	0x03, 0	; 3
 394:	fe cf       	rjmp	.-4      	; 0x392 <writePS2+0x54>

    // 7)   Wait for the device to bring Clock low.
    waitCLKfall();
 396:	18 99       	sbic	0x03, 0	; 3
 398:	fe cf       	rjmp	.-4      	; 0x396 <writePS2+0x58>

    data >>= 1;
 39a:	86 95       	lsr	r24
 39c:	21 50       	subi	r18, 0x01	; 1
  // 4)   Wait for the device to bring the Clock line low.
  waitCLKfall();



  for (i = 0; i < 8; i++)
 39e:	89 f7       	brne	.-30     	; 0x382 <writePS2+0x44>

    // 8)   Repeat steps 5-7 for the other seven data bits
  } // for
  //
  // and the parity bit
  if (parity & 0x01)
 3a0:	90 ff       	sbrs	r25, 0
 3a2:	03 c0       	rjmp	.+6      	; 0x3aa <writePS2+0x6c>
  {
    releaseDAT();
 3a4:	21 98       	cbi	0x04, 1	; 4
 3a6:	29 9a       	sbi	0x05, 1	; 5
 3a8:	02 c0       	rjmp	.+4      	; 0x3ae <writePS2+0x70>
  } else {
    dropDAT();
 3aa:	21 9a       	sbi	0x04, 1	; 4
 3ac:	29 98       	cbi	0x05, 1	; 5
  }

  waitCLKrise();
 3ae:	18 9b       	sbis	0x03, 0	; 3
 3b0:	fe cf       	rjmp	.-4      	; 0x3ae <writePS2+0x70>
  waitCLKfall();
 3b2:	18 99       	sbic	0x03, 0	; 3
 3b4:	fe cf       	rjmp	.-4      	; 0x3b2 <writePS2+0x74>

  // 9)   Release the Data line.
  releaseDAT();
 3b6:	21 98       	cbi	0x04, 1	; 4
 3b8:	29 9a       	sbi	0x05, 1	; 5
 3ba:	e5 e3       	ldi	r30, 0x35	; 53
 3bc:	ea 95       	dec	r30
 3be:	f1 f7       	brne	.-4      	; 0x3bc <writePS2+0x7e>
 3c0:	00 00       	nop
  _delay_us(10);

  // 10) Wait for the device to bring Data low.
  waitDATfall();
 3c2:	19 99       	sbic	0x03, 1	; 3
 3c4:	fe cf       	rjmp	.-4      	; 0x3c2 <writePS2+0x84>

  // 11) Wait for the device to bring Clock  low.
  waitCLKrise();
 3c6:	18 9b       	sbis	0x03, 0	; 3
 3c8:	fe cf       	rjmp	.-4      	; 0x3c6 <writePS2+0x88>

  // 12) Wait for the device to release Data and Clock
  waitDATrise();
 3ca:	19 9b       	sbis	0x03, 1	; 3
 3cc:	fe cf       	rjmp	.-4      	; 0x3ca <writePS2+0x8c>
  waitCLKrise();
 3ce:	18 9b       	sbis	0x03, 0	; 3
 3d0:	fe cf       	rjmp	.-4      	; 0x3ce <writePS2+0x90>

  // Hold data line low to hold keyboard until next action
  dropDAT();
 3d2:	21 9a       	sbi	0x04, 1	; 4
 3d4:	29 98       	cbi	0x05, 1	; 5
 3d6:	08 95       	ret

000003d8 <readPS2>:
  uint16_t shiftRegister = 0;

  uint16_t mask = 0x0001;

  // Prepare for receive
  releaseCLK();
 3d8:	20 98       	cbi	0x04, 0	; 4
 3da:	28 9a       	sbi	0x05, 0	; 5
  releaseDAT();
 3dc:	21 98       	cbi	0x04, 1	; 4
 3de:	29 9a       	sbi	0x05, 1	; 5
 3e0:	87 ec       	ldi	r24, 0xC7	; 199
 3e2:	90 e0       	ldi	r25, 0x00	; 0
 3e4:	01 97       	sbiw	r24, 0x01	; 1
 3e6:	f1 f7       	brne	.-4      	; 0x3e4 <readPS2+0xc>
 3e8:	00 c0       	rjmp	.+0      	; 0x3ea <readPS2+0x12>
 3ea:	00 00       	nop
 3ec:	2b e0       	ldi	r18, 0x0B	; 11
uint8_t readPS2() {
  uint8_t data;
  uint8_t i;
  uint16_t shiftRegister = 0;

  uint16_t mask = 0x0001;
 3ee:	41 e0       	ldi	r20, 0x01	; 1
 3f0:	50 e0       	ldi	r21, 0x00	; 0
// Receive one byte from PS/2 device

uint8_t readPS2() {
  uint8_t data;
  uint8_t i;
  uint16_t shiftRegister = 0;
 3f2:	80 e0       	ldi	r24, 0x00	; 0
 3f4:	90 e0       	ldi	r25, 0x00	; 0
  releaseDAT();
  _delay_us(50);

  // receive 11 bits
  for (i = 0; i < 11; i++)   {
    waitCLKfall();
 3f6:	18 99       	sbic	0x03, 0	; 3
 3f8:	fe cf       	rjmp	.-4      	; 0x3f6 <readPS2+0x1e>
 3fa:	3a e1       	ldi	r19, 0x1A	; 26
 3fc:	3a 95       	dec	r19
 3fe:	f1 f7       	brne	.-4      	; 0x3fc <readPS2+0x24>
 400:	00 c0       	rjmp	.+0      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
    _delay_us(5);

    if ( readDAT() )
 402:	19 9b       	sbis	0x03, 1	; 3
 404:	02 c0       	rjmp	.+4      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
      shiftRegister |= mask;
 406:	84 2b       	or	r24, r20
 408:	95 2b       	or	r25, r21

    waitCLKrise();
 40a:	18 9b       	sbis	0x03, 0	; 3
 40c:	fe cf       	rjmp	.-4      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
    mask <<= 1;     // point next bit
 40e:	44 0f       	add	r20, r20
 410:	55 1f       	adc	r21, r21
 412:	21 50       	subi	r18, 0x01	; 1
  releaseCLK();
  releaseDAT();
  _delay_us(50);

  // receive 11 bits
  for (i = 0; i < 11; i++)   {
 414:	81 f7       	brne	.-32     	; 0x3f6 <readPS2+0x1e>
    waitCLKrise();
    mask <<= 1;     // point next bit
  }

  // hold clock line to inhibt further data
  dropCLK();
 416:	20 9a       	sbi	0x04, 0	; 4
 418:	28 98       	cbi	0x05, 0	; 5

  // todo test for parity, framing, etc
  data = (uint8_t) (shiftRegister >> 1);

  return data;
 41a:	96 95       	lsr	r25
 41c:	87 95       	ror	r24
}
 41e:	08 95       	ret

00000420 <main>:
};

/////////////////////////////////////////////////////////////////////////////////////////////////

int main (void) {
   setup();
 420:	0e 94 74 01 	call	0x2e8	; 0x2e8 <setup>
   for (;;) loop ();
 424:	0e 94 91 01 	call	0x322	; 0x322 <loop>

00000428 <_exit>:
 428:	f8 94       	cli

0000042a <__stop_program>:
 42a:	ff cf       	rjmp	.-2      	; 0x42a <__stop_program>
